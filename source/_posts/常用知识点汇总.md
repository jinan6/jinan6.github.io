---
title: 常用知识点汇总
tags: 记录
categories: 记录
abbrlink: 961488241
date: 2020-06-25 15:12:15
cover: https://cdn.jsdelivr.net/gh/1790735465/butterfly_image/img/20200611140842.jpg
sticky:
top_img:
---

{% note success %}
🌳🌳🌳数据库方面
{% endnote %}

## 数据库优化------->MySQL

### MySQL四个优化方向

**设计角度：** 存储引擎的选择，字段类型选择，范式。

**自身特性：**索引，查询缓存，分区分表，存储过程，SQL语句优化配置

**架构体系：**主从复制（读写分离）

**硬件升级：**CPU、内存等。

#### 选择合适的存储引擎

1. MYISAM  查询快，增删慢 表锁
2. InnoDB 支持事务，并发 行锁

#### 表结构优化

1. 恰当的字段类型
2. 范式
3. 水平划分
4. 垂直划分

### SQL优化

避免使用  select  *   like   or

### MySQL存储引擎

#### InnoDB和MYISAM的区别

1. InnoDB 支持主外键、事务
2. InnoDB 是行锁，操作时候只锁一行数据，适合高并发；MYISAM是表锁
3. InnoDB 不仅缓存索引，还缓存真实数据；MYISAM只缓存索引
4. InnoDB 需要表空间大
5. InnoDB 关注事务，MYISAM关注性能（查）；



### 索引

索引：排好序的快速查找数据结构

优点：提高数据检索的效率，降低数据排序的成本

缺点：会降低更新表的速度



单值索引：一个索引只包含单个列，一个表可以由多个单值索引

唯一索引：索引列的值必须唯一，允许有空值

符合索引：即一个索引包含多个列

### 索引失效

1. 最好全值匹配
2. 最左前缀法则：如果索引了多列，查询从索引的最左前列开始，且不能跳过索引中的列
3. 不在索引列上做任何操作（计算，函数，类型转换），会导致索引时校而转向全表扫描
4. 存储引擎不能使用索引中范围条件右边的列，即范围之后全失效
5. 尽量使用覆盖索引，只访问索引的查询（索引列和查询列一致），减少   select *
6. MySQL在使用不等于的时候无法使用索引会导致全表扫描
7. is null， is not null 也无法使用索引
8. like  以通配符开头  （'%aa'）索引会失效，变成全表扫描
9. 字符串不加单引号，索引失效
10. 少用  or ，用它连的接时候索引会失效

### Mysql命令增加、修改、删除表字段

#### 增加

alter add命令格式：alter table 表名 add字段 类型 其他；如下所示：

```sql
alter table car_evidence add `unit_name` varchar(64) comment '单位'
```

#### 删除

alter drop 命令格式：alter table 表名 drop column 字段；

```sql
alter table car_evidence drop column `unit_name`; 
```

#### 修改

　alter modify 命令格式：alter table 表名 modify 字段 其他；如下所示：

```sql
alter table t_plan MODIFY box_size VARCHAR(32) comment '盒内的数量';
```



{% btn 'http://localhost:4000/posts/3155752545/',点击这里查看更多,far fa-hand-point-right,purple larger %}

------

{% note info %}
🍊🍊🍊代码题
{% endnote %}

## 代码题

### 用java实现求1到100数偶数以及个数

```java
    public static void main(String[] args) {
        System.out.println("1到100之间的偶数为：");
        int sum=0;
        for(int i=1;i<101;i++){
            if (i%2==0){
                System.out.println("偶数为："+i);
                sum++;
            }
        }
        System.out.println("偶数的个数为："+sum);
    }
```

### 求闰年

```java
    public static void main(String[] args) {
//        求闰年
        int sum = 0;
        for (int i=2000;i<=2020;i++){
            if (i%4==0&&i%100!=0||i%400==0){
                sum++;
                System.out.println("闰年为：" + i);
            }
        }
        System.out.println("个数为：" + sum);
    }
```

### ArrayList

```java
public class List {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add("1");
        list.add("2");
        list.add("3");
        list.add("4");
        list.add("5");
        // for循环输出
        for (int i=0;i<list.size();i++){
            System.out.println(list.get(i));
        }
        //  迭代器输出
        Iterator i = list.iterator();
        while(i.hasNext()){
            System.out.println(i.next());
        }
        
        //默认调用toString
        System.out.println("\n--------toString---------");
        System.out.println(list);


        //正向输出
        System.out.println("\n----正向输出---");
        ListIterator li = list.listIterator();
        while(li.hasNext()){
            System.out.print(li.next());
        }
        System.out.println("\n-----反向输出--------");


        //反向输出
        while(li.hasPrevious()){
            System.out.print(li.previous());
        }
    }
}
```

### HashMap 高性能输出

```java
     public static void main(String[] args) {
        Map<String,String> map = new HashMap<String, String>();
        map.put("1","111");
        map.put("2","222");
        map.put("3","333");

        // 默认使用tostring
        System.out.println(map);

        //低效
        Set keys = map.keySet();
        for (Object key : keys) {
            System.out.print(key+"="+map.get(key)+" ");
        }

        System.out.println("\n");

        //高效
        for (Map.Entry<String,String> me:map.entrySet()) {
            System.out.print(me.getKey()+"="+me.getValue()+" ");
        }
    }
```

------

{% note warning %}
🍓🍓🍓面向对象
{% endnote %}

## 面向对象

### 面向对象的三大特征

1. 封装
2. 继承
3. 多态

### 类

1. 类就是`相同属性`和`方法`的集合
2. 定义类的关键字  **class**
3. 类的继承  **extends**

### 抽象类

是一种特殊的，不能被实例化的类，只能为其他类的父类使用

使用  **abstract** 关键字声明

### 接口

1. 定义接口的关键字   **interface**
2. 实现接口的关键字  **implements**
3. 接口继承接口的关键字  **extends**
4. 接口是一种特殊的抽象类，也是一个特殊的类，可实现多继承
5. 接口中的所有方法都必须是抽象方法
6. 接口中的属性必须是常量
7. 一个类可以实现多个接口

### 常用关键字

1. **final**  用来修饰类和方法，不能再有子类或者被继承
2. **static**  声明静态类的成员

### 重写和重载

#### 重写(Override)

子类对父类的方法进行重写，返回值和形参都不能改变，只改变方法体

方法重写的关键是：在子类中创建与父类相同的方法

#### 重载(Overload)

重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

### 简答题

#### 表单传值方式有什么，简述其区别

1. get   post 
2. get  明文传输 ，不安全，传输快，传输量小
3. post  加密传输 ，安全，传输慢，传输量大

#### 抽象类和接口的区别

1. 【继承方式】抽象类的操作通过继承关键字extends实现，而接口的使用是通过implements关键字来实现
2. 【属性】 抽象类中有数据成员，可以实现数据的封装，但是接口没有数据成员
3. 【构造方法】抽象类中可以有构造方法，但是接口没有构造方法
4. 【修饰符】抽象类的方法可以通过private、protected、public关键字修饰（抽象方法不能是private），而接口中的方法只能使用public关键字修饰
5. 【继承关系】一个类只能继承于一个抽象类（单继承），而一个类可以同时实现多个接口。（抽象类只能被单继承，接口可以被多实现）
6. 【普通方法】抽象类中可以有成员方法的实现代码，而接口中不可以有成员方法的实现代码
7. 抽象类是单继承、接口是多实现

#### 三个（public protected  private）权限修饰符，修饰的范围

1. public修饰的成员为公有的，可以在类内、子类以及类外进行访问
2. protected修饰的成员为受保护的，可以在类内和子类中访问
3. private修饰的成员为私有的，只能在本类内进行访问

####  请写出封装的含义？为什么

主要是为了安全和方便。隐藏不想让外界直接访问到的属性或实现细节（方法），只提供访问入口

#### 请写出继承的含义？为什么 

派生类（子类）自动继承一个或多个基类（父类）中的非私有的属性和方法，并可以重写或添加新的属性或方法

代码复用

####  请写出多态的含义？为什么

同一类的不同对象使用同一个方法可以获得不同的结果，并可以进行方法的重写，增加了软件的灵活性和重用性

#### 什么是抽象类

1. 抽象类和普通类相似，都可以有成员变量和成员方法（普通方法），但不能是private的
2. 要有一个抽象方法。即使用abstract修饰的没有方法体的方法
3. 若一个类中存在一个抽象方法，则该类必须声明为抽象类，但一个抽象类中不是必须有抽象方法（抽象类中可以没有抽象方法）

#### 简述什么是MVC

1. Model（模型）
   1. 是应用程序中用于处理应用程序数据逻辑的部分
   2. 通常模型对象负责在数据库中存取数据
2. View（视图）
   1. 是应用程序中处理数据显示的部分
   2. 通常视图是依据模型数据创建的
3. Controller（控制器）
   1. 是应用程序中处理用户交互的部分
   2. 通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据

#### 列出几种设计模式

工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式

适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式

#### final修饰的类和方法具有什么特点

1. 可以修饰类和方法，但不能修饰成员属性
2. final修饰的类，不能被继承
3. final修饰的成员方法，在子类中不能被重写

------

{% note danger %}
🍉🍉🍉Spring Boot
{% endnote %}

## Spring Boot

### 什么是 Spring Boot

Spring Boot是Spring社区发布的一个开源项目，旨在帮助开发者快速并且更简单的构建项目。大多数SpringBoot项目只需要很少的配置文件。开箱即用 约定大于配置 

### SpringBoot自动配置的原理

在spring程序main方法中 添加@SpringBootApplication或者@EnableAutoConfiguration
会自动去maven中读取每个starter中的spring.factories文件 该文件里配置了所有需要被创建spring容器中的bean

### SprinBoot读取配置文件的方式

springboot默认读取配置文件为application.properties或者是application.yml

### SpringBoot优缺点

#### 优点：

1. 快速构建项目
2. 对主流开发框架的无配置集成。
3. 项目可独立运行，无须外部依赖Servlet容器。
4. 提供运行时的应用监控。
5. 极大的提高了开发、部署效率。
6. 与云计算的天然集成。

#### 缺点：

如果你不认同spring框架，也许这就是缺点。

### SpringBoot几个常用的注解

1. @RestController和@Controller指定一个类，作为控制器的注解 
2. @RequestMapping方法级别的映射注解，这一个用过Spring MVC的小伙伴相信都很熟悉 
3. @EnableAutoConfiguration和@SpringBootApplication是类级别的注解，根据maven依赖的jar来自动猜测完成正确的spring的对应配置，只要引入了spring-boot-starter-web的依赖，默认会自动配置Spring MVC和tomcat容器
4. @Configuration类级别的注解，一般这个注解，我们用来标识main方法所在的类,完成元数据bean的初始化。
5. @ComponentScan类级别的注解，自动扫描加载所有的Spring组件包括Bean注入，一般用在main方法所在的类上 
6. @ImportResource类级别注解，当我们必须使用一个xml的配置时，使用@ImportResource和@Configuration来标识这个文件资源的类。 
7. @Autowired注解，一般结合@ComponentScan注解，来自动注入一个Service或Dao级别的Bean
8. @Component类级别注解，用来标识一个组件，比如我自定了一个filter，则需要此注解标识之后，Spring Boot才会正确识别。

### spring的IOC 和AOP

#### IOC

IOC 控制反转
首先：IOC（Inverse of Contro）控制反转，有时候也被称为DI依赖注入，它是一种降低对象耦合关系的一种设计思想。

#### AOP

AOP  切面编程
概念：AOP面向切面编程，是面向对象开发的一种补充，它允许开发人员在不改变原来模型的以满足新的需求，例如，开发人员可以在不改变原来业务逻辑模型的基础可以进行动态的增加日志，安全或异常处理功能。

{% btn 'https://jinan6.vip/posts/1864766114/',点击这里查看更多,far fa-hand-point-right,blue larger %}

------

{% note default %}
🍒🍒🍒Mybatis
{% endnote %}

## Mybatis

### 什么是MyBatis？

MyBatis是一个可以自定义SQL、存储过程和高级映射的持久层框架。

### 请描述下MyBatis的缓存?

MyBatis的缓存分为一级缓存和二级缓存,一级缓存放在session里面,默认就有,二级缓存放在它的命名空间里,默认是不打开的,使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置< cache/>

### #{}和${}的区别是什么？

1. #{}是预编译处理，${}是字符串替换。
2. Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；
3. Mybatis在处理${}时，就是把${}替换成变量的值。
4. 使用#{}可以有效的防止SQL注入，提高系统安全性。

### MyBatis框架适用场合?

1. MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案
2. 对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择

{% btn 'https://jinan6.vip/posts/3661501281/',点击这里查看更多,far fa-hand-point-right,orange larger %}

------

{% note success %}
🌿🌿🌿Linux
{% endnote %}

## Linux

### 填空

1. 默认情况下，超级用户和普通用户的登录提示符分别是`#`和`$`
2. Linux系统中有三种基本的文件类型 `普通文件`、`目录文件`、`设备文件`
3. 跳到/usr/bin 命令为 `d  /usr/bin`，跳到目前目录的上上两层 `cd  ../..`
4. 查看目录命令为`ls`；列出目录下的所有文件`-a`；列出文件的详细信息`-l`
5. `cat`命令用于显示文本内容时，加选项 `-n` 可以在显示时加上行编号.
6. 分屏显示命令：`more` ，清除屏幕命令`clear` 。
7. 复制命令`cp`，复制时删除已经存在的目标文件而不提示 `-f` ，递归复制该目录下所有的子目录和文件命令 `-r`
8. 删除命令 `rm`
9. 在当前目录下创建目录abc：`#mkdir abc` ,创建多级目录a/b/c：`#mkdir -p a/b/c`
10. 用户有唯一的用户标识符`uid`  ,组标识符`gid`。
11.  显示当前目录：`pwd`
12. 删除一个非空子目录：`rm -rf /tmp`
13. 存放用户帐号的文件：`passwd`
14.  删除文件命令：`rm`
15. 列出当前目录以及子目录下所有扩展名：`find . –name 文件名称 `
16. 设定使用者的密码：`passwd`
17. 切换使用者身份：`su`
18. 文件重命名的命令：`mv`
19. 可以显示目录的大小：`du`
20. 下面哪个系统目录中存放了启动时使用的一些文件和目录：`/boot`
21. 如何删除目录 /tmp下的所有文件及子目录：`rm –rf /tmp/*`
22. 把当前目录下的 file1.txt 复制为 file2.txt的命令：`cat file1.txt > file2.txt `
23.  如果执行命令 #chmod 746 file.txt，那么该文件的权限是：` rwx--r--rw` （对应746）
24. vim退出不保存的命令：`:q!`
25.  全屏文本编辑器：`v` 

### Linux文件有几种典型的权限，分别是？普通文件权限和目录权限的区别是

1. r（read）读
2. w（write） 写
3. x （execute） 执行

#### 区别

1. 目录
   1. r权限(READ，读取)  和 x权限(EXCUTE，执行) 的结合才允许列出目录的内容。w权限(WRITE，写入) 和 x权限(ExCUTE，执行) 的结合 则允许在目录中创建、删除和重新命名文件。
2. 文件
   1. 文件不用结合x权限 

### 若下达rmdir命令来删除某个已存在的目录，但无法成功，请说明可能的原因

1. 此目录可能不存在
2. 目录不为空
3. 目录中有隐含文件存在
4. 目录被设置了权限，解决方法：先修改权限，在使用rm_r命令删除

### 与其他操作系统相比，Linux具有那些显著的特点

1. 模块化程度高
2. 源码公开
3.   广泛的硬件支持
4. 安全性及可靠性好
5. 有很好的网络支持利文件系统支持
6. 与UNIX完全兼容

### vi编辑器有哪几种工作模式？如何在这几种工作模式之间转换

#### 命令模式

在命令模式下输入a、A、i、I、o、O等命令之一可以进入输入模式，

#### 输入模式

在输入模式下按Esc键回到命令模式

#### 末行模式 

在命令模式下按下:（英文冒号）就进入了末行模式末行命令执行完后回到命令模式

- q 退出程序
- w 保存文件

### linux试述如何创建一个用户 

可使用命令useradd创建新用户，但不能在系统中随便创建用户，

需经相关部分批准后方能创建。对于长期或暂时不使用的用户，应将其从

系统中删除或锁定起来，以防非法使用。创建新用户时可以使用命令useradd -d 

home newuser指定用户家目录，若不指定则使用默认的家目录/home/newuser。一般情况下，

当一个用户被创建之后，只有超级用户为它设置密码后才能被启用或登录使用。

````code
// 1
useradd test //*建立用户test*//

passwd test //*设置用户test密码*//
        修改/etc/password文件
````

```code
//  2
useradd 选项 用户名

参数说明：选项 :
   -c comment 指定一段注释性描述。
   -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。
   -g 用户组 指定用户所属的用户组。
   -G 用户组，用户组 指定用户所属的附加组。
   -m　使用者目录如不存在则自动建立。
   -s Shell文件 指定用户的登录Shell。
   -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识
```

------

{% note info %}
🍍🍍🍍其他
{% endnote %}

## 其他

### JSON

json是一种轻量级的数据交换格式。

### Ajax

```java
$.ajax({
　　　　url : "Servlet",　　　　//传地址
　　　　type : "post",　　　　//类型 
　　　　async : "true",　　　　//是否异步
　　　　data : { "action": "action" },　　//数据
　　　　dataType : "json",　　　　　　//数据格式
　　　　success : function(data){　　　　//成功后操作
　　　　　　alert("AJAX");
　　　　}
　　});
```

### 同步和异步

**同步方法**调用一但开始，调用者必须等到方法调用返回后，才能继续向后执行

**异步方法**调用一但开始，方法调用就会立即返回，可以继续向后执行

异步方法通常会在另一个线程中执行，整个过程，不会阻碍调用者的工作



**同步：**

同步的思想是：所有的操作都做完，才返回给用户。这样用户在线等待的时间太长，给用户一种卡死了的感觉（就是系统迁移中，点击了迁移，界面就不动了，但是程序还在执行，卡死了的感觉）。这种情况下，用户不能关闭界面，如果关闭了，即迁移程序就中断了。

**异步：**

将用户请求放入消息队列，并反馈给用户，系统迁移程序已经启动，你可以关闭浏览器了。然后程序再慢慢地去写入数据库去。这就是异步。但是用户没有卡死的感觉，会告诉你，你的请求系统已经响应了。你可以关闭界面了。



### JDBC的优缺点

#### 优点：

直接底层操作，提供了很简单，便捷的访问数据库的方法，跨平台型比较强，灵活性比较强，可以写很复杂的SQL语句

#### 缺点：

操作比较繁琐。很多代码需要重复写很多次

如果遇到批量操作，频繁与数据库进行交互，容易造成效率的下降

JDBC没有做到使数据能够面向对象的编程，使程序员的思考仍停留在SQL语句上



### 数组的两个异常

1. 下标越界异常
2. 空指针异常