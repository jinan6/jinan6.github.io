---
title: 常用知识点汇总
tags: 记录
categories: 记录
abbrlink: 961488241
date: 2020-06-25 15:12:15
cover: https://cdn.jsdelivr.net/gh/1790735465/butterfly_image/img/20200611140842.jpg
sticky:
top_img:
---

{% note success %}
数据库方面
{% endnote %}

## 数据库优化------->MySQL

### MySQL四个优化方向

**设计角度：** 存储引擎的选择，字段类型选择，范式。

**自身特性：**索引，查询缓存，分区分表，存储过程，SQL语句优化配置

**架构体系：**主从复制（读写分离）

**硬件升级：**CPU、内存等。

#### 选择合适的存储引擎

1. MYISAM  查询快，增删慢 表锁
2. InnoDB 支持事务，并发 行锁

#### 表结构优化

1. 恰当的字段类型
2. 范式
3. 水平划分
4. 垂直划分

### SQL优化

避免使用  select  *   like   or

### MySQL存储引擎

#### InnoDB和MYISAM的区别

1. InnoDB 支持主外键、事务
2. InnoDB 是行锁，操作时候只锁一行数据，适合高并发；MYISAM是表锁
3. InnoDB 不仅缓存索引，还缓存真实数据；MYISAM只缓存索引
4. InnoDB 需要表空间大
5. InnoDB 关注事务，MYISAM关注性能（查）；



### 索引

索引：排好序的快速查找数据结构

优点：提高数据检索的效率，降低数据排序的成本

缺点：会降低更新表的速度



单值索引：一个索引只包含单个列，一个表可以由多个单值索引

唯一索引：索引列的值必须唯一，允许有空值

符合索引：即一个索引包含多个列



### Mysql命令增加、修改、删除表字段

#### 增加

alter add命令格式：alter table 表名 add字段 类型 其他；如下所示：

```sql
alter table car_evidence add `unit_name` varchar(64) comment '单位'
```

#### 删除

alter drop 命令格式：alter table 表名 drop column 字段；

```sql
alter table car_evidence drop column `unit_name`; 
```

#### 修改

　alter modify 命令格式：alter table 表名 modify 字段 其他；如下所示：

```sql
alter table t_plan MODIFY box_size VARCHAR(32) comment '盒内的数量';
```



### 索引失效

1. 最好全值匹配
2. 最左前缀法则：如果索引了多列，查询从索引的最左前列开始，且不能跳过索引中的列
3. 不在索引列上做任何操作（计算，函数，类型转换），会导致索引时校而转向全表扫描
4. 存储引擎不能使用索引中范围条件右边的列，即范围之后全失效
5. 尽量使用覆盖索引，只访问索引的查询（索引列和查询列一致），减少   select *
6. MySQL在使用不等于的时候无法使用索引会导致全表扫描
7. is null， is not null 也无法使用索引
8. like  以通配符开头  （'%aa'）索引会失效，变成全表扫描
9. 字符串不加单引号，索引失效
10. 少用  or ，用它连的接时候索引会失效

{% note info %}
代码题
{% endnote %}

## 代码题

### 用java实现求1到100数偶数以及个数

```java
    public static void main(String[] args) {
        System.out.println("1到100之间的偶数为：");
        int sum=0;
        for(int i=1;i<100;i++){
            if (i%2==0){
                System.out.println("偶数为："+i);
            }
            sum++;
        }
        System.out.println("个数为："+sum);
    }
```

### 求闰年

```java
    public static void main(String[] args) {
//        求闰年
        int sum = 0;
        for (int i=2000;i<=2020;i++){
            if (i%4==0&&i%100!=0||i%400==0){
                sum++;
                System.out.println("闰年为：" + i);
            }
        }
        System.out.println("个数为：" + sum);
    }
```

### ArrayList

```java
public class List {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add("1");
        list.add("2");
        list.add("3");
        list.add("4");
        list.add("5");
        // for循环输出
        for (int i=0;i<list.size();i++){
            System.out.println(list.get(i));
        }
        //  迭代器输出
        Iterator i = list.iterator();
        while(i.hasNext()){
            System.out.println(i.next());
        }
        
        //默认调用toString
        System.out.println("\n--------toString---------");
        System.out.println(list);


        //正向输出
        System.out.println("\n----正向输出---");
        ListIterator li = list.listIterator();
        while(li.hasNext()){
            System.out.print(li.next());
        }
        System.out.println("\n-----反向输出--------");


        //反向输出
        while(li.hasPrevious()){
            System.out.print(li.previous());
        }
    }
}
```

### HashMap 高性能输出

```java
     public static void main(String[] args) {
        Map<String,String> map = new HashMap<String, String>();
        map.put("1","111");
        map.put("2","222");
        map.put("3","333");

        // 默认使用tostring
        System.out.println(map);

        //低效
        Set keys = map.keySet();
        for (Object key : keys) {
            System.out.print(key+"="+map.get(key)+" ");
        }

        System.out.println("\n");

        //高效
        for (Map.Entry<String,String> me:map.entrySet()) {
            System.out.print(me.getKey()+"="+me.getValue()+" ");
        }
    }
```

{% note warning %}
面向对象
{% endnote %}

## 面向对象

### 面向对象的三大特征

1. 封装
2. 继承
3. 多态

### 类

1. 类就是相同属性和方法的集合
2. 定义类的关键字  **class**
3. 类的继承  **extends**

### 抽象类

是一种特殊的，不能被实例化的类，只能为其他类的父类使用

使用  **abstract** 关键字声明

### 接口

1. 定义接口的关键字   **interface**
2. 实现接口的关键字  **implements**
3. 接口继承接口的关键字  **extends**
4. 接口是一种特殊的抽象类，也是一个特殊的类，可实现多继承
5. 接口中的所有方法都必须是抽象方法
6. 接口中的属性必须是常量
7. 一个类可以实现多个接口

### 常用关键字

1. **final**  用来修饰类和方法，不能再有子类或者被继承
2. **static**  声明静态类的成员

### 重写和重载

#### 重写(Override)

子类对父类的方法进行重写，返回值和形参都不能改变，只改变方法体

方法重写的关键是：在子类中创建与父类相同的方法

#### 重载(Overload)

重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

### 简答题

#### 表单传值方式有什么，简述其区别

1. get   post 
2. get  明文传输 ，不安全，传输快，传输量小
3. post  加密传输 ，安全，传输慢，传输量大

#### 抽象类和接口的区别

1. 【继承方式】抽象类的操作通过继承关键字extends实现，而接口的使用是通过implements关键字来实现
2. 【属性】 抽象类中有数据成员，可以实现数据的封装，但是接口没有数据成员
3. 【构造方法】抽象类中可以有构造方法，但是接口没有构造方法
4. 【修饰符】抽象类的方法可以通过private、protected、public关键字修饰（抽象方法不能是private），而接口中的方法只能使用public关键字修饰
5. 【继承关系】一个类只能继承于一个抽象类（单继承），而一个类可以同时实现多个接口。（抽象类只能被单继承，接口可以被多实现）
6. 【普通方法】抽象类中可以有成员方法的实现代码，而接口中不可以有成员方法的实现代码
7. 抽象类是单继承、接口是多实现

#### 三个（public protected  private）权限修饰符，修饰的范围

1. public修饰的成员为公有的，可以在类内、子类以及类外进行访问
2. protected修饰的成员为受保护的，可以在类内和子类中访问
3. private修饰的成员为私有的，只能在本类内进行访问

####  请写出封装的含义？为什么

主要是为了安全和方便。隐藏不想让外界直接访问到的属性或实现细节（方法），只提供访问入口

#### 请写出继承的含义？为什么 

派生类（子类）自动继承一个或多个基类（父类）中的非私有的属性和方法，并可以重写或添加新的属性或方法

代码复用

####  请写出多态的含义？为什么

同一类的不同对象使用同一个方法可以获得不同的结果，并可以进行方法的重写，增加了软件的灵活性和重用性

#### 什么是抽象类

1. 抽象类和普通类相似，都可以有成员变量和成员方法（普通方法），但不能是private的
2. 要有一个抽象方法。即使用abstract修饰的没有方法体的方法
3. 若一个类中存在一个抽象方法，则该类必须声明为抽象类，但一个抽象类中不是必须有抽象方法（抽象类中可以没有抽象方法）

#### 简述什么是MVC

1. Model（模型）
   1. 是应用程序中用于处理应用程序数据逻辑的部分
   2. 通常模型对象负责在数据库中存取数据
2. View（视图）
   1. 是应用程序中处理数据显示的部分
   2. 通常视图是依据模型数据创建的
3. Controller（控制器）
   1. 是应用程序中处理用户交互的部分
   2. 通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据

#### 列出几种设计模式

工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式

适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式

#### final修饰的类和方法具有什么特点

1. 可以修饰类和方法，但不能修饰成员属性
2. final修饰的类，不能被继承
3. final修饰的成员方法，在子类中不能被重写

{% note primary no-icon %}
Spring Boot
{% endnote %}

## Spring Boot

### 什么是 Spring Boot

Spring Boot是Spring社区发布的一个开源项目，旨在帮助开发者快速并且更简单的构建项目。大多数SpringBoot项目只需要很少的配置文件。开箱即用 约定大于配置 

### SpringBoot自动配置的原理

在spring程序main方法中 添加@SpringBootApplication或者@EnableAutoConfiguration
会自动去maven中读取每个starter中的spring.factories文件 该文件里配置了所有需要被创建spring容器中的bean

### SprinBoot读取配置文件的方式

springboot默认读取配置文件为application.properties或者是application.yml

### SpringBoot优缺点

#### 优点：

1. 快速构建项目
2. 对主流开发框架的无配置集成。
3. 项目可独立运行，无须外部依赖Servlet容器。
4. 提供运行时的应用监控。
5. 极大的提高了开发、部署效率。
6. 与云计算的天然集成。

#### 缺点：

如果你不认同spring框架，也许这就是缺点。

### SpringBoot几个常用的注解

1. @RestController和@Controller指定一个类，作为控制器的注解 
2. @RequestMapping方法级别的映射注解，这一个用过Spring MVC的小伙伴相信都很熟悉 
3. @EnableAutoConfiguration和@SpringBootApplication是类级别的注解，根据maven依赖的jar来自动猜测完成正确的spring的对应配置，只要引入了spring-boot-starter-web的依赖，默认会自动配置Spring MVC和tomcat容器
4. @Configuration类级别的注解，一般这个注解，我们用来标识main方法所在的类,完成元数据bean的初始化。
5. @ComponentScan类级别的注解，自动扫描加载所有的Spring组件包括Bean注入，一般用在main方法所在的类上 
6. @ImportResource类级别注解，当我们必须使用一个xml的配置时，使用@ImportResource和@Configuration来标识这个文件资源的类。 
7. @Autowired注解，一般结合@ComponentScan注解，来自动注入一个Service或Dao级别的Bean
8. @Component类级别注解，用来标识一个组件，比如我自定了一个filter，则需要此注解标识之后，Spring Boot才会正确识别。

### spring的IOC 和AOP

#### IOC

IOC 控制反转
首先：IOC（Inverse of Contro）控制反转，有时候也被称为DI依赖注入，它是一种降低对象耦合关系的一种设计思想。

#### AOP

AOP  切面编程
概念：AOP面向切面编程，是面向对象开发的一种补充，它允许开发人员在不改变原来模型的以满足新的需求，例如，开发人员可以在不改变原来业务逻辑模型的基础可以进行动态的增加日志，安全或异常处理功能。

{% note default %}
Mybatis
{% endnote %}

{% btn 'https://jinan6.vip/posts/1864766114/',点击这里查看更多,far fa-hand-point-right,blue larger %}

## Mybatis

### 什么是MyBatis？

MyBatis是一个可以自定义SQL、存储过程和高级映射的持久层框架。

### 请描述下MyBatis的缓存?

MyBatis的缓存分为一级缓存和二级缓存,一级缓存放在session里面,默认就有,二级缓存放在它的命名空间里,默认是不打开的,使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置< cache/>

### #{}和${}的区别是什么？

1. #{}是预编译处理，${}是字符串替换。
2. Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；
3. Mybatis在处理${}时，就是把${}替换成变量的值。
4. 使用#{}可以有效的防止SQL注入，提高系统安全性。

### MyBatis框架适用场合?

1. MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案
2. 对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择

{% btn 'https://jinan6.vip/posts/3661501281/',点击这里查看更多,far fa-hand-point-right,orange larger %}

